# -*- coding: utf-8 -*-
"""recipes1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1upNiCVJ5QCRRMk7IxVgzSmYh0UBc8joO

# Разработка
Вы должны создать модуль Python (recipes.py) с классами и методами, которые используются в основной программе.
"""

import pandas as pd
import numpy as np
import joblib
import warnings
from sklearn.ensemble import RandomForestClassifier
warnings.filterwarnings('ignore')
import random

class Forecast:
    """
    Предсказание рейтинга блюда или его класса
    """

    def __init__(self, list_of_ingredients):
        """
        Добавьте сюда любые поля и строчки кода, которые вам покажутся нужными.
        """
        self.list_of_ingredients = list_of_ingredients
        self.list_of_ingredients = self.list_of_ingredients.lower()
        self.list_of_ingredients = self.list_of_ingredients.split(",")
        self.list_of_ingredients = [x.strip(' ') for x in self.list_of_ingredients]

    def preprocess(self):
        """
        Этот метод преобразует список ингредиентов в структуры данных,
        которые используются в алгоритмах машинного обучения, чтобы сделать предсказание.
        """
        df = pd.read_csv('data/recipes.csv')
        groceries = df.columns[6:]
        vector = pd.DataFrame(data=np.zeros((1, len(groceries))), columns=groceries)
        for i in list(groceries):
            if i in self.list_of_ingredients:
                vector[i] = 1.0
        self.vector = vector
        return self.vector

    #def predict_rating(self):
        """
        Этот метод возвращает рейтинг для списка ингредиентов, используя регрессионную модель,
        которая была обучена заранее. Помимо самого рейтинга, метод также возвращает текст,
        который дает интерпретацию этого рейтинга и дает рекомендацию, как в примере выше.
        """


    #    return rating, text

    def predict_rating_category(self):
        """
        Этот метод возращает рейтинговую категорию для списка ингредиентов, используя классификационную модель,
        которая была обучена заранее. Помимо самого рейтинга, метод возвращает также и текст,
        который дает интерпретацию этой категории и дает рекомендации, как в примере выше.
        """
        model = joblib.load('data/best_RandomForestClassifier.joblib')
        rating_cat = model.predict(self.vector)
        if rating_cat == 'great':
            text = 'Вкусное. Отличный выбор продуктов!'
        if rating_cat == 'so-so':
            text = 'Нормальное. Но может пересмотрим что-то в списке продуктов?'
        if rating_cat == 'bad':
            text = 'Невкусное. Хоть конкретно вам может быть и понравится блюдо из этих ингредиентов, но, на наш взгляд, это плохая идея – готовить блюдо из них. Хотели предупредить.'
        rating_cat = rating_cat
        return rating_cat, text

class NutritionFacts:
    """
    Выдает информацию о пищевой ценности ингредиентов.
    """

    def __init__(self, list_of_ingredients):
        """
        Добавьте сюда любые поля и строчки кода, которые вам покажутся нужными.
        """
        self.list_of_ingredients = list_of_ingredients
        self.list_of_ingredients = self.list_of_ingredients.lower()
        self.list_of_ingredients = self.list_of_ingredients.split(",")
        self.list_of_ingredients = [x.strip(' ') for x in self.list_of_ingredients]

    def retrieve(self):
        """
        Этот метод получает всю имеющуюся информацию о пищевой ценности из файла с заранее собранной информацией по заданным ингредиентам.
        Он возвращает ее в том виде, который вам кажется наиболее удобным и подходящим.
        """
        df = pd.read_csv('data/nutrition.csv')
        for i in self.list_of_ingredients:
            if i == self.list_of_ingredients[0]:
                nutr = df.loc[df['food_product'] == i]
                df_nutr = nutr
            else:
                nutr = df.loc[df['food_product'] == i]
                df_nutr = pd.concat([df_nutr, nutr])
        df_nutr.reset_index(drop=True, inplace=True)
        for x in range(len(df_nutr)):
            df_nutr['value'][x] = round(df_nutr['value'][x] * 100, 0)
            df_nutr['nutrition'][x] = df_nutr['nutrition'][x].split(',')[0]

        df_nutr = df_nutr.loc[df_nutr['value'] > 0]
        df_nutr = df_nutr.sort_values(by=['food_product', 'value'], ascending=False)
        df_nutr.reset_index(drop=True, inplace=True)
        self.facts = df_nutr
        return self.facts

    #def filter(self, must_nutrients, n):
        """
        Этот метод отбирает из всей информации о пищевой ценности только те нутриенты, которые были заданы в must_nutrients (пример в PDF-файле ниже),
        а также топ-n нутриентов с наибольшим значением дневной нормы потребления для заданного ингредиента.
        Он возвращает текст, отформатированный как в примере выше.
        """

    #  return text_with_facts

class SimilarRecipes:
    """
    Рекомендация похожих рецептов с дополнительной информацией
    """

    def __init__(self, list_of_ingredients):
        """
        Добавьте сюда любые поля и строчки кода, которые вам покажутся нужными.
        """
        self.list_of_ingredients = list_of_ingredients
        self.list_of_ingredients = self.list_of_ingredients.lower()
        self.list_of_ingredients = self.list_of_ingredients.split(",")
        self.list_of_ingredients = [x.strip(' ') for x in self.list_of_ingredients]

    def find_all(self):
        """
        Этот метод возвращает список индексов рецептов, которые содержат заданный список ингредиентов.
        Если нет ни одного рецепта, содержащего все эти ингредиенты, то сделайте обработку ошибки, чтобы программа не ломалась.
        """
        df = pd.read_csv('data/recipes.csv')
        for i in self.list_of_ingredients:
            if i == self.list_of_ingredients[0]:
                df_rec = df.loc[df[i] == 1]
                df_recipes = df_rec
            else:
                df_rec = df.loc[df[i] == 1]
                df_recipes = pd.concat([df_recipes, df_rec])
        df_recipes = df_recipes.drop_duplicates(keep='first')
        df_recipes.reset_index(drop=True, inplace=True)
        df_recipes['ing'] = df_recipes['val']
        df_recipes['ing_n'] = df_recipes['val']
        for x in range(len(df_recipes)):
            df_recipes['ing'][x] = 0
            for y in self.list_of_ingredients:
                df_recipes['ing'][x] = df_recipes['ing'][x] + df_recipes[y][x]
            df_recipes['ing_n'][x] = df_recipes['val'][x] - df_recipes['ing'][x]
        df_recipes = df_recipes.sort_values(by=['ing', 'ing_n'], ascending=[False, True])
        self.indexes = df_recipes
        return self.indexes

    def top_similar(self):
        """
        Этот метод возвращает текст, форматированный как в примере выше: с заголовком, рейтингом и URL.
        Чтобы это сделать, он вначале находит топ-n наиболее похожих рецептов с точки зрения количества дополнительных ингредиентов,
        которые потребуются в этих рецептах. Наиболее похожим будет тот, в котором не требуется никаких других ингредиентов.
        Далее идет тот, у которого появляется 1 доп. ингредиент. Далее – 2.
        Если рецепт нуждается в более, чем 5 доп. ингредиентах, то такой рецепт не выводится.
        """
        text_with_recipes = self.indexes
        text_with_recipes = text_with_recipes.loc[text_with_recipes['ing_n'] <= 5]
        text_with_recipes.reset_index(drop=True, inplace=True)
        return text_with_recipes

    def menu_for_day(self):
        """
        Метод случайным образом выводит список из трех рецептов, которые подходят для завтрака, обеда и ужина, соответственно,
        и покрывают большую часть потребностей в питании, а также имеют самую высокую оценку.
        """
        df = pd.read_csv('data/recipes.csv')
        df_breakfast = df.loc[df['meal'] == 'breakfast']
        df_breakfast = df_breakfast.loc[df_breakfast['class'] == 'great']
        df_breakfast = df_breakfast.loc[df_breakfast['val'] >= 3]
        breakfast = df_breakfast.loc[random.choice(list(df_breakfast.index))]
        cc = breakfast['title']
        df_breakfast = df_breakfast.loc[df_breakfast['title'] == cc]
        df_breakfast.reset_index(drop=True, inplace=True)
        groceries = df_breakfast.columns[6:]
        vv = []
        for a in groceries:
            if df_breakfast[a][0] == 1:
                vv.append(a)
        df2 = pd.read_csv('data/nutrition.csv')
        for i in vv:
            if i == vv[0]:
                nutr = df2.loc[df2['food_product'] == i]
                df_nutr = nutr
            else:
                nutr = df2.loc[df2['food_product'] == i]
                df_nutr = pd.concat([df_nutr, nutr])
        table_breakfast = pd.pivot_table(df_nutr, values='value', index=['nutrition'], aggfunc=np.sum)
        table_breakfast.reset_index(drop=False, inplace=True)
        for i in range(len(table_breakfast)):
            table_breakfast['value'][i] = round(table_breakfast['value'][i] * 100, 0)
            table_breakfast['nutrition'][i] = table_breakfast['nutrition'][i].split(',')[0]
        table_breakfast = table_breakfast.sort_values(by=['value'], ascending=[False])
        table_breakfast.reset_index(drop=True, inplace=True)
        breakfast_name = cc
        breakfast_food = vv
        breakfast_url = df_breakfast['url'][0]
        breakfast_rating = df_breakfast['rating'][0]
        breakfast_nutrition = table_breakfast
        #-----------------------------------------------------------------------
        df_lunch = df.loc[df['meal'] == 'lunch']
        df_lunch = df_lunch.loc[df_lunch['class'] == 'great']
        df_lunch = df_lunch.loc[df_lunch['val'] >= 3]
        lunch = df_lunch.loc[random.choice(list(df_lunch.index))]
        cc = lunch['title']
        df_lunch = df_lunch.loc[df_lunch['title'] == cc]
        df_lunch.reset_index(drop=True, inplace=True)
        groceries = df_lunch.columns[6:]
        vv = []
        for a in groceries:
            if df_lunch[a][0] == 1:
                vv.append(a)
        for i in vv:
            if i == vv[0]:
                nutr = df2.loc[df2['food_product'] == i]
                df_nutr = nutr
            else:
                nutr = df2.loc[df2['food_product'] == i]
                df_nutr = pd.concat([df_nutr, nutr])
        table_lunch = pd.pivot_table(df_nutr, values='value', index=['nutrition'], aggfunc=np.sum)
        table_lunch.reset_index(drop=False, inplace=True)
        for i in range(len(table_lunch)):
            table_lunch['value'][i] = round(table_lunch['value'][i] * 100, 0)
            table_lunch['nutrition'][i] = table_lunch['nutrition'][i].split(',')[0]
        table_lunch = table_lunch.sort_values(by=['value'], ascending=[False])
        table_lunch.reset_index(drop=True, inplace=True)
        lunch_name = cc
        lunch_food = vv
        lunch_url = df_lunch['url'][0]
        lunch_rating = df_lunch['rating'][0]
        lunch_nutrition = table_lunch
        #-----------------------------------------------------------------------
        df_dinner = df.loc[df['meal'] == 'dinner']
        df_dinner = df_dinner.loc[df_dinner['class'] == 'great']
        df_dinner = df_dinner.loc[df_dinner['val'] >= 3]
        dinner = df_dinner.loc[random.choice(list(df_dinner.index))]
        cc = dinner['title']
        df_dinner = df_dinner.loc[df_dinner['title'] == cc]
        df_dinner.reset_index(drop=True, inplace=True)
        groceries = df_dinner.columns[6:]
        vv = []
        for a in groceries:
            if df_dinner[a][0] == 1:
                vv.append(a)
        for i in vv:
            if i == vv[0]:
                nutr = df2.loc[df2['food_product'] == i]
                df_nutr = nutr
            else:
                nutr = df2.loc[df2['food_product'] == i]
                df_nutr = pd.concat([df_nutr, nutr])
        table_dinner = pd.pivot_table(df_nutr, values='value', index=['nutrition'], aggfunc=np.sum)
        table_dinner.reset_index(drop=False, inplace=True)
        for i in range(len(table_dinner)):
            table_dinner['value'][i] = round(table_dinner['value'][i] * 100, 0)
            table_dinner['nutrition'][i] = table_dinner['nutrition'][i].split(',')[0]
        table_dinner = table_dinner.sort_values(by=['value'], ascending=[False])
        table_dinner.reset_index(drop=True, inplace=True)
        dinner_name = cc
        dinner_food = vv
        dinner_url = df_dinner['url'][0]
        dinner_rating = df_dinner['rating'][0]
        dinner_nutrition = table_dinner
        return dinner_name,dinner_food,dinner_url,dinner_rating,dinner_nutrition,lunch_name, lunch_food, lunch_url, lunch_rating, lunch_nutrition,breakfast_name, breakfast_food, breakfast_url, breakfast_rating, breakfast_nutrition